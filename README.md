# GOF Design Patterns

One of my favourity overview of the most common GOF patteterns is this stackoverflow question:

http://stackoverflow.com/questions/1673841/examples-of-gof-design-patterns-in-javas-core-libraries

its based one real world examples in java core libraries.

# Code Katas

Since I read the Book "Clean Coder" I got very excited about Code Katas.
Uncle Bob tells us in his book that he is doing one or two Katas daily.
I'm tying to keep up with that

Goals for my Code Training

* Spend 20 hours per week in addition to your work (those hours are for me - I try to spend it for reading, practicing, learning
* "Professionals spend time caring for their profession"
* "You should not be working for your company during those 20 hours. Instead you should work on your career"



Minimal List of Things that every software professional should be conversant with:

Design patterns (describe all 25 patterns of the GOF book, including examples)

* Design principles (know the SOLID principles)
* Methods (understand XP, Scrum, Lean, Kanban, Waterfall, Structured Analysis)
* Disciplines (practice TDD, Pair Programming)
* Artifacts (UML, DFD, Petri Nets,..)
* 


# SOLID Design principles

https://zeroturnaround.com/rebellabs/object-oriented-design-principles-and-the-5-ways-of-creating-solid-applications/

* Single Responsibility Priniciple ("just because you can, doesnt mean you should")
The Single Responsibility Principle (SRP) states that there should never be more than one reason for a class to change.

* Open Close Principle ("you dont need to rewrite your Motherboard to plug in a USB stick")
The Open-Closed Principle (OCP) states that classes should be open for extension but closed for modification.

* Liskov Substitution Principle (If it looks like a Duck, Qacks like a Duck, but needs batteries - you probably have the wrong abstraction")
The Liskov Substitution Principle (LSP) applies to inheritance hierarchies, specifying that you should design your classes so that client dependencies can be substituted with subclasses without the client knowing about the change.

* Interface Segregation Principle ("If IRequireFood, I want to Eat(Food food) not, LightCalabra() or LayoutCuterly(CuterlyLayout preferredLayout) ")
The Interface Segregation Principle (ISP) states that clients should not be forced to depend upon interface members they do not use. When we have non-cohesive interfaces, the ISP guides us to create multiple, smaller, cohesive interfaces.

* Dependency Inversion Principle (" Would you solder a lamp directly to the electrical wiring in a wall")
The Dependency Inversion Principle (DIP) states that high-level modules should not depend upon low-level modules; they should depend on abstractions.


# Algorithms

* Monte Carlos
* Different search and sorting Algorithms
* Maze solving
* Traveling sales man
![alt tag](http://imgs.xkcd.com/comics/travelling_salesman_problem.png)
* Social network 
* Recursion
* Tree
* Graph





